#include "triangle_quadrature_rules.h"
#include <stdexcept>
#include <cmath>

namespace {

// ---- Degree <= 1 ----
constexpr int N1 = 1;
constexpr double W1[N1] = {
  0.5
};
constexpr double C1_2[N1][2] = {
  { 0.3333333333333333333333333333333, 0.3333333333333333333333333333333 }
};

// ---- Degree <= 2 ----
constexpr int N2 = 3;
constexpr double W2[N2] = {
  0.1666666666666666666666666666666,
  0.1666666666666666666666666666666,
  0.1666666666666666666666666666666
};
constexpr double C2_2[N2][2] = {
  { 0.6666666666666666666666666666666, 0.1666666666666666666666666666666 },
  { 0.1666666666666666666666666666666, 0.6666666666666666666666666666666 },
  { 0.1666666666666666666666666666666, 0.1666666666666666666666666666666 }
};

// ---- Degree <= 4 (6 pts, Dunavant) ----
constexpr int N4 = 6;
constexpr double W4[N4] = {
  0.0549758718276609338191631624501052,
  0.0549758718276609338191631624501052,
  0.0549758718276609338191631624501052,
  0.111690794839005732847503504216561,
  0.111690794839005732847503504216561,
  0.111690794839005732847503504216561
};
constexpr double C4_2[N4][2] = {
  { 0.8168475729804585130808570731956,   0.0915762135097707434595714634022015 },
  { 0.0915762135097707434595714634022015, 0.8168475729804585130808570731956   },
  { 0.0915762135097707434595714634022015, 0.0915762135097707434595714634022015 },
  { 0.1081030181680702273633414922339,   0.445948490915964886318329253883051  },
  { 0.445948490915964886318329253883051, 0.1081030181680702273633414922339    },
  { 0.445948490915964886318329253883051, 0.445948490915964886318329253883051  }
};

// ---- Degree <= 8 (16 pts, Dunavant) ----
constexpr int N8 = 16;
constexpr double W8[N8] = {
  0.072157803838893584125545555249701,
  0.051608685267359125140895775145648,
  0.051608685267359125140895775145648,
  0.051608685267359125140895775145648,
  0.016229248811599040155462964170437,
  0.016229248811599040155462964170437,
  0.016229248811599040155462964170437,
  0.047545817133642312396948052190887,
  0.047545817133642312396948052190887,
  0.047545817133642312396948052190887,
  0.013615157087217497132422345038231,
  0.013615157087217497132422345038231,
  0.013615157087217497132422345038231,
  0.013615157087217497132422345038231,
  0.013615157087217497132422345038231,
  0.013615157087217497132422345038231
};
constexpr double C8_2[N8][2] = {
  { 0.33333333333333333333333333333333, 0.33333333333333333333333333333333 },
  { 0.1705693077517602066222935014994,  0.1705693077517602066222935014994  },
  { 0.1705693077517602066222935014994,  0.65886138449647958675541299700121 },
  { 0.65886138449647958675541299700121, 0.1705693077517602066222935014994  },
  { 0.050547228317030975458423550596387, 0.050547228317030975458423550596387 },
  { 0.050547228317030975458423550596387, 0.89890554336593804908315289880723 },
  { 0.89890554336593804908315289880723, 0.050547228317030975458423550596387 },
  { 0.45929258829272315602881551450124, 0.45929258829272315602881551450124 },
  { 0.45929258829272315602881551450124, 0.081414823414553687942368970997513 },
  { 0.081414823414553687942368970997513, 0.45929258829272315602881551450124 },
  { 0.72849239295540428124100037918962, 0.26311282963463811342178578626121 },
  { 0.26311282963463811342178578626121, 0.72849239295540428124100037918962 },
  { 0.72849239295540428124100037918962, 0.0083947774099576053372138345491687 },
  { 0.0083947774099576053372138345491687, 0.72849239295540428124100037918962 },
  { 0.26311282963463811342178578626121, 0.0083947774099576053372138345491687 },
  { 0.0083947774099576053372138345491687, 0.26311282963463811342178578626121 }
};

template <int N>
inline void expand_to_barycentric(const double (&C2)[N][2],
                                  std::vector<Eigen::Vector3d>& cs) {
  cs.reserve(cs.size() + N);
  for (int i = 0; i < N; ++i) {
    const double a = C2[i][0], b = C2[i][1];
    cs.emplace_back(1.0 - a - b, a, b);
  }
}

} // anonymous

namespace quad {

TriRule get_triangle_fe2_rule(int deg) {
  TriRule r;

  if (deg <= 1) {
    r.w.assign(W1, W1 + N1);
    expand_to_barycentric<N1>(C1_2, r.cs);
  } else if (deg <= 2) {
    r.w.assign(W2, W2 + N2);
    expand_to_barycentric<N2>(C2_2, r.cs);
  } else if (deg <= 4) {
    r.w.assign(W4, W4 + N4);
    expand_to_barycentric<N4>(C4_2, r.cs);
  } else if (deg <= 8) {
    r.w.assign(W8, W8 + N8);
    expand_to_barycentric<N8>(C8_2, r.cs);
  } else {
    throw std::runtime_error("triangle FE2 rule: only degrees 1,2,4,8 are compiled in");
  }

#ifndef NDEBUG
  double sw = 0.0; for (double wi : r.w) sw += wi;
  if (std::abs(sw - 0.5) > 1e-12) {
    throw std::runtime_error("Triangle FE2: weights must sum to 1/2 on reference triangle.");
  }
  for (const auto& b : r.cs) {
    const double s = b[0] + b[1] + b[2];
    if (std::abs(s - 1.0) > 1e-14) {
      throw std::runtime_error("Triangle FE2: barycentric row does not sum to 1.");
    }
  }
#endif

  return r;
}

} // namespace quad
